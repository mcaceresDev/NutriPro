ICONOS
<i class="fa-solid fa-circle-h"></i> // H de historial
<i class="fa-solid fa-file-medical"></i> //Hoja medica hoja+
<i class="fa-solid fa-file-waveform"></i> //Hoja + estado de corazon


BASE DE DATOS
===============================================================================
Tablas
medicamentos
nutrientes
interacciones
(Opcional) enfermedades

-- Crear base de datos
CREATE DATABASE nutri_interacciones;
USE nutri_interacciones;

-- Tabla de medicamentos
CREATE TABLE medicamentos (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    grupo_farmacologico VARCHAR(100),
    descripcion TEXT
);

-- Tabla de nutrientes o alimentos
CREATE TABLE nutrientes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    tipo ENUM('nutriente', 'alimento') DEFAULT 'nutriente',
    categoria VARCHAR(100),
    descripcion TEXT
);

-- Tabla de enfermedades (opcional, pero útil para relacionar casos como diabetes o dislipidemia)
CREATE TABLE enfermedades (
    id INT AUTO_INCREMENT PRIMARY KEY,
    nombre VARCHAR(100) NOT NULL,
    descripcion TEXT
);

-- Tabla de interacciones
CREATE TABLE interacciones (
    id INT AUTO_INCREMENT PRIMARY KEY,
    medicamento_id INT NOT NULL,
    nutriente_id INT NOT NULL,
    enfermedad_id INT NULL,
    tipo ENUM('positiva', 'negativa') NOT NULL,
    efecto TEXT NOT NULL,
    recomendacion TEXT,
    nivel_evidencia ENUM('alta', 'media', 'baja') DEFAULT 'media',
    FOREIGN KEY (medicamento_id) REFERENCES medicamentos(id),
    FOREIGN KEY (nutriente_id) REFERENCES nutrientes(id),
    FOREIGN KEY (enfermedad_id) REFERENCES enfermedades(id)
);




{
  "medicamento": "Metformina",
  "interaccion": "Disminuye absorción de vitamina B12",
  "efecto": "Posible anemia megaloblástica",
  "recomendacion": "Monitorear B12 anual y recomendar alimentos fortificados o suplemento"
}
============================================================================
configuracion general
============================================================================

require("dotenv").config();
const axios = require("axios")
const { DateTime } = require("luxon")
const { Op } = require('sequelize');
const { Bitacora } = require("./models");
const express = require("express")
const path = require("path")
const session = require('express-session');
const router = require("./routes");
const SQLiteStore = require('connect-sqlite3')(session)
const cron = require("node-cron")

//VARIABLES DE APP Y MIDDLEWARES
const app = express()
app.use(express.json())
app.use(express.urlencoded({ extended: true }))
app.use(express.static(path.join(__dirname, 'public')))

const PORT = process.env.APPLICATION_PORT ? process.env.APPLICATION_PORT : 3000

app.use(session({
    store: new SQLiteStore({
        db: 'sessions.sqlite',
        dir: path.join(__dirname, 'database'),
        // cleanupInterval: 15 * 60 * 1000 //Revisa y limpia sesiones expiradas cada 15 minutos de acuerdo al maxAge.
    }),
    secret: process.env.SECRET_KEY ? process.env.SECRET_KEY : "$2b$10$n3SSI",
    resave: false,
    saveUninitialized: false,
    cookie: { secure: false } // true si usas HTTPS
    //   cookie: {
    //     maxAge: 1000 * 60 * 60 * 24 // 1 día (en milisegundos)
    //   }

}));

app.set('view engine', 'ejs');
app.set('views', path.join(__dirname, 'views'));
app.use('/', router)
app.use((req, res) => {
    res.status(404).sendFile(__dirname + '/views/pages/notFoundPage.html');
});

app.listen(PORT, () => {
    console.log("Servidor corriendo...");
})

// Ejecutar cada 10 minutos
cron.schedule("*/15 * * * *", async () => {
    // console.log("⏳ Iniciando verificación de mensajes...");
    const ahora = new Date();
    ahora.setHours(ahora.getHours() - 6)
    const hace24h = new Date();
    hace24h.setHours(ahora.getHours() - 26)//Se consulta de hace 26 horas para luego eliminar los que hayan alcanzado las 24 horas o mas sin confirmacion

    try {
        // 1. Buscar todos los mensajes enviados en las últimas 24h
        const mensajes = await Bitacora.findAll({
            where: {
                status: "Enviado",
                sendDate: { [Op.gte]: hace24h }
            }
        });
        
        if (mensajes.length === 0) {
            // console.log("No hay mensajes pendientes de verificación.");
            return;
        }

        // 2. Agrupar referencias en string separado por comas
        const referencias = mensajes.map(m => m.reference).join(",");

        // 3. Consultar API de Tigo
        const { data } = await axios.post(`/api/confirmar-lista-sms`, { referencias });

        if (!data || data.length <= 0) {
            console.warn("⚠️ Respuesta sin lista de estados:", data);
            return;
        }

        if (data.estado && data.referencia) { //Significa que solo vino un dato en forma de Objeto
            const { estado } = data
            if (estado === "CON") {
                let fechaConfirmado = new Date()
                fechaConfirmado.setHours(fechaConfirmado.getHours() - 6)
                await mensajes[0].update({ status: "Entregado", responseDate: fechaConfirmado });
            } 
            else {
                // calcular horas transcurridas
                const tiempoEnvio = new Date(mensajes[0].sendDate);
                const diffHoras = (ahora.getTime() - tiempoEnvio.getTime()) / (1000 * 60 * 60);

                if (diffHoras >= 24) {
                    await mensajes[0].update({ status: "Fallido" });
                }
            }
            return
        }

        // 4. Procesar resultados
        for (const estadoMsg of data) {
            const { referencia, estado } = estadoMsg;

            // buscar el mensaje en DB
            const msg = mensajes.find(m => m.reference === referencia);
            if (!msg) continue;

            if (estado === "CON") {
                let fechaConfirmado = new Date()
                fechaConfirmado.setHours(fechaConfirmado.getHours() - 6)
                await msg.update({ status: "Entregado", responseDate: fechaConfirmado });
            } else {
                // calcular horas transcurridas
                const tiempoEnvio = new Date(msg.sendDate);
                const diffHoras = (ahora.getTime() - tiempoEnvio.getTime()) / (1000 * 60 * 60);
                
                if (diffHoras >= 24) {
                    await msg.update({ status: "Fallido" });
                }
            }
        }

        console.log(`✅ Verificados ${mensajes.length} mensajes.`);
    } catch (err) {
        console.error("❌ Error en verificación de mensajes:", err.message);
    }
});

==========================================================================================================
ESTRUCTURA MODELOS CON TYPESCRIPT
==========================================================================================================
import { DataTypes, Association, Model, InferAttributes, InferCreationAttributes, CreationOptional, ForeignKey } from 'sequelize';
import db from '../config/dbConnection';
import Category from './category';
// import Invoice from './invoice';

export interface ProductInterface {
  id?:number;
  name:string;
  description?:string;
  purchasePrice:number;
  salePrice1:number;
  salePrice2:number;
  salePrice3:number;
  stock:number;
  minStock:number;
  maxStock?:number;
  barCode?:string;
  lab?:string;
  categoryId?:number;
  providerId?:number;
  infoId?:number;
}

class Product extends Model<InferAttributes<Product>, InferCreationAttributes<Product>> {
  declare id: CreationOptional<number>;
  declare name: string;
  declare description: CreationOptional<string>;
  declare purchasePrice: number;
  declare salePrice1: number;
  declare salePrice2: number;
  declare salePrice3: number;
  declare stock: number;
  declare minStock: number;
  declare maxStock: number;
  declare barCode: string;
  declare lab: string;
  declare providerId: ForeignKey<Category['id']> //Llaves foraneas
  declare categoryId: ForeignKey<Category['id']>
  declare infoId: ForeignKey<Category['id']>

  // timestamps!
  declare createdAt: CreationOptional<Date>;
  declare updatedAt: CreationOptional<Date>;
  declare deletedAt: CreationOptional<Date>;

}

Product.init({
  id: {
    type: DataTypes.INTEGER,
    autoIncrement: true,
    primaryKey: true
  },
  name: {
    type: DataTypes.STRING,
    allowNull: false,
    validate: {
      notNull: { msg: "El campo nombre no puede ser nulo" },
      notEmpty: { msg: "El campo nombre no puede ser vacío" }
    }
  },
  description: {
    type: DataTypes.STRING,
  },
  purchasePrice: {
    type: DataTypes.DECIMAL(6,2),
    // allowNull: false,
    // validate: {
    //   isDecimal: true,
    //   notNull: {msg: "el campo precio no puede ser nulo"},
    //   notEmpty: {msg: "el campo precio no puede ir vacío"}
    // }
  },
  salePrice1: {
    type: DataTypes.DECIMAL(6,2),
    allowNull: false,
    validate: {
      isDecimal: true,
      notNull: {msg: "el campo precio no puede ser nulo"},
      notEmpty: {msg: "el campo precio no puede ir vacío"}
    }
  },
  salePrice2: {
    type: DataTypes.DECIMAL(6,2),
  },
  salePrice3: {
    type: DataTypes.DECIMAL(6,2),
  },
  stock: {
    type: DataTypes.INTEGER,
    validate: {
      isNumeric: true,
      isInt: true,
      min: {args: [0], msg: "Las existencias de producto no pueden ser menores a 0"}
    }
  },
  minStock: {
    type: DataTypes.INTEGER,
    validate: {
      isNumeric: true,
      isInt: true,
      min: {args: [0], msg: "Las existencias de producto no pueden ser menores a 0"}
    }
  },
  maxStock: {
    type: DataTypes.INTEGER,
    validate: {
      isNumeric: true,
      isInt: true,
      min: {args: [0], msg: "Las existencias de producto no pueden ser menores a 0"}
    }
  },
  barCode: {
    type: DataTypes.STRING
  },
  lab: {
    type: DataTypes.STRING
  },
  categoryId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    validate: {
      notNull: {msg: "Debes asociar una categoría a este producto"},
      notEmpty: {msg: "Debes asociar una categoría a este producto"}
    }
  },
  infoId: {
    type: DataTypes.INTEGER
  },
  createdAt: DataTypes.DATE,
  updatedAt: DataTypes.DATE,
  deletedAt: {type: DataTypes.DATE}
}, {
  sequelize: db,
  modelName: 'Product',
  freezeTableName: true,
  paranoid: true
});


export default Product;